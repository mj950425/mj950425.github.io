2024/02/25

# 왜 비동기 IO가 컨택스트 스위칭을 줄여주는가?

이벤트 핸들링 방식은 아래와 같이 동작합니다.

먼저 가용하는 스레드가 10개 있다고 가정합니다. 

이벤트 핸들링 스레드라고 불리우는 1개의 스레드는 다른 작업은 하지않고 주기적으로 아래 동작을 수행합니다.

1. 비즈니스 로직 시작: 애플리케이션의 메인 스레드가 실행되며, 특정 시점에서 비동기 I/O 작업을 수행해야 할 필요가 있습니다.

2. 비동기 I/O 작업 요청: 비즈니스 로직 스레드는 비동기 I/O 작업을 시작하기 위해 해당 작업을 운영체제에 요청합니다. 이때, 작업이 완료될 때 실행될 콜백 함수도 함께 등록합니다. 이 요청은 비동기적으로 처리되므로, 비즈니스 로직 스레드는 I/O 작업이 완료되기를 기다리지 않고 다른 작업을 계속 진행할 수 있습니다.

3. I/O 컨트롤러 작업 수행: 운영체제는 비동기 I/O 요청을 받고, 이를 I/O 컨트롤러에 전달하여 실제 I/O 작업을 수행하게 합니다. I/O 컨트롤러는 하드웨어 장치와의 통신을 담당하며, 요청된 I/O 작업을 직접 처리합니다.

4. 이벤트 발생과 이벤트 큐: I/O 작업이 완료되면, I/O 컨트롤러는 작업 완료 이벤트를 생성하고, 이 이벤트를 이벤트 큐에 배치합니다. 이벤트 큐는 이벤트 루프가 주기적으로 확인하는 대기열입니다.

5. 이벤트 루프 처리: 이벤트 핸들러 스레드는 이벤트 큐를 주기적으로 폴링하여 대기 중인 이벤트가 있는지 확인합니다. 대기 중인 이벤트를 발견하면, 해당 이벤트와 연결된 콜백 함수를 꺼내 실행합니다. 이 콜백 함수는 비동기 I/O 작업의 결과를 처리하는 로직을 포함합니다.

6. 콜백 함수 실행과 비즈니스 로직의 계속: 콜백 함수가 실행되면, 비동기 I/O 작업의 결과를 처리하고 필요한 경우 추가적인 비즈니스 로직을 실행할 수 있습니다. 이 과정에서 새로운 비동기 작업이 시작될 수도 있습니다.



먼저 비동기 작업을 만나면 큐에 넣습니다.

그리고 해당 작업을 이벤트 루프가 주기적으로 폴링합니다.

그리고 정해진 쓰레드풀의 스레드가 해당 작업을 처리합니다.

IO작업이 완료되면 콜백을 처리한다.

예를 들어서 하나의 메인 스레드만 존재한다고 가정해보겠습니다.

하나의 메인 스레드는 non blocking IO로 동작한다고하면, 10개의 비동기 작업을 완료까지 기다리지않고 실행합니다.

그렇기 때문에 컨텍스트 스위칭이 필요 없습니다.

웹플럭스 같은 모델에서 만약에 특정 데이터를 파일시스템에서 읽어서 1을 더한뒤에 반환하는 로직이 있다면, 해당 로직을 수행하기 이전에 다음 로직으로 넘어갈 수 없다.

그래서 해당 스레드는 다른 유저의 요청을 처리하러 간다.

# 왜 동기 IO가 컨택스트 스위칭 비용을 증가시키는가?
쓰레드가 블로킹되면 CPU를 바로 다른 스레드에게 양보하고, 해당 스레드는 블락 상태이므로 컨택스트 스위칭의 대상이 되지 않는다.

하지만 다른 스레드에게 CPU를 앙보할떄 컨택스트 스위칭이 발생한다. 또한, 스레드가 다시 동작해야할떄 컨택스트 스위칭이 발생한다.

100개의 스레드가 블락되면 블락되는데 컨택스트 스위칭이 100번, 다시 ready 상태에서 run 상태로 돌아가는데 100번 발생한다.

하지만 블락 상태의 스레드는 스택 메모리, 레지스터 등등 다른 정보들을 점유한다.

또한 IO작업이 완료되었는지 운영체제가 주기적으로 트래킹해야한다.

동기 모델의 예시
상황: 10개의 파일에서 데이터를 읽어와야 하는 작업이 있습니다.

작업 시작: 10개의 스레드 (Thread-1부터 Thread-10까지) 각각이 파일에서 데이터를 읽기 시작합니다.
블로킹 발생: 각 스레드는 파일 읽기 작업이 완료될 때까지 블로킹됩니다. 이 동안에 CPU는 다른 작업을 수행할 수 있습니다.
컨텍스트 스위칭: 각 스레드가 블로킹되면, 운영체제는 CPU를 다른 스레드에 할당하기 위해 컨텍스트 스위칭을 수행합니다.
작업 완료 후 복귀: 파일 읽기 작업이 완료되면, 해당 스레드는 다시 실행 대기 상태가 되고, 운영체제는 이 스레드를 CPU에 할당하기 위해 다시 컨텍스트 스위칭을 수행합니다.

비동기 모델의 예시
상황: 같은 10개의 파일에서 데이터를 읽어와야 하는 작업이 있습니다.

작업 시작: 단일 스레드 (Event-Loop)가 10개의 파일 읽기 작업을 비동기적으로 시작합니다. 각 작업은 콜백 함수나 프로미스로 결과를 처리합니다.
비블로킹: Event-Loop는 파일 읽기 작업이 완료될 때까지 기다리지 않고, 즉시 다음 작업을 시작합니다. 이렇게 모든 파일 읽기 요청이 비동기적으로 시작됩니다.
컨텍스트 스위칭 최소화: Event-Loop는 계속해서 다른 작업을 처리할 수 있으므로, 컨텍스트 스위칭이 발생하지 않습니다. 모든 I/O 작업이 백그라운드에서 진행됩니다.
작업 완료 처리: 파일 읽기 작업이 완료되면, Event-Loop는 콜백 함수나 프로미스를 통해 결과를 처리합니다. 이 과정에서도 추가적인 컨텍스트 스위칭은 발생하지 않습니다.

비교
동기 모델: 각 I/O 작업에 대해 별도의 스레드가 필요하며, 각 스레드가 블로킹될 때마다 컨텍스트 스위칭이 발생합니다. 이는 총 10개의 스레드가 블로킹되고 다시 활성화될 때마다 컨텍스트 스위칭이 2회씩 발생하므로, 총 20회의 컨텍스트 스위칭이 발생합니다.
비동기 모델: 단일 Event-Loop 스레드가 모든 I/O 작업을 처리합니다. 작업을 시작하거나 완료할 때 별도의 컨텍스트 스위칭이 필요 없으므로, 컨텍스트 스위칭이 대폭 줄어듭니다.
결론적으로, 비동기 모델은 동기 모델에 비해 훨씬 적은 컨텍스트 스위칭을 발생시키며, 이는 전반적인 시스템 성능과 효율성을 개선합니다.

# 멀티스레딩에서의 비동기 작업에서 스레드풀을 사용해야하는 이유
그렇다면 i/o작업이 일어날때마다 매번 스레드를 만들어서 비동기로 동작시키는것은 컨택스트 스위칭 비용이 늘어날 수 있어서 좋은 구조는 아니고, 적절한 숫자의 i/o작업을 처리하는 스레드풀을 두고 메인 스레드는 i/o요청이 있을때마다 여기에 요청하고 블락되지않는다면 컨택스트 스위칭의 비용이 크게 줄어드는 좋은 구조가 될까?
