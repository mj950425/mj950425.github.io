---
layout: post
title: "T&A 3.0 프로젝트 설계 및 기술적 회고"
date: 2024-06-09 08:46:00 +0900
categories:
  - dev
  - project
description: >
  '투어&티켓 전체 리뉴얼 프로젝트'
---

# T&A 3.0 프로젝트 설계 및 기술적 회고
![그림1](/assets/img/experience/project-review/tna3-project/img_11.png)

T&A 3.0 프로젝트 설계에 대한 내용과, 팀 내부에서 기술적 회고를 공유한 경험을 글로 기록했습니다.

# 개요

![그림1](/assets/img/experience/project-review/tna3-project/img_8.png)
<br/>
저는 회사에서 투어와 티켓을 판매하는 T&A 개발팀에 속해 있으며, 이 팀은 회사 내에서 가장 큰 영업 이익을 창출하는 부서입니다.

이 시스템은 10년 전에 루비로 개발되었습니다.

시간이 흐르면서 여러 문제가 발견되었고, 사업부의 다양한 요구사항을 반영하기 위해 코틀린으로 시스템을 재구축하는 T&A 3.0 프로젝트를 진행하게 되었습니다.

2023년 10월에 프로젝트를 시작해 2024년 5월에 정식으로 서비스를 오픈했습니다.

초기에는 루비 개발자들 사이에서 코틀린 프로젝트의 아키텍처 설계를 담당했으며, 이후 재고 및 상품 등의 다양한 도메인 개발을 맡았습니다.

설계 과정을 통해 다양한 트레이드 오프를 경험을 할 수 있었고, 이를 글로 기록해보았습니다.

# 도메인

도메인은 캘린더, 상품, 옵션, 재고, 예약으로 구성되어있습니다.

바운디드 컨택스트는 크게 파트너, 매니저, 여행자로 구성되어있습니다.

초반 설계시에 바운디드 컨택스트에 따라 파트너, 매니저, 여행자로 레포지토리를 분리하는 방식을 제안했습니다만, 팀 내에 중복 코드에 대한 우려가 있었고, 이에 따라 단일 레포에서 코드를 구성하게됐습니다.

그러나 여행자와 파트너, 매니저의 서버가 달라야한다는 기술적 요구사항은 존재했습니다.

이에 따라, 단일 레포에서 여행자와 백오피스의 api와 application 모듈은 분리했고, 나머지는 공통으로 사용했습니다.

이렇게 만들어진 구조는 아래와 같습니다.

![그림1](/assets/img/experience/project-review/tna3-project/img_9.png)

멀티 모듈 아키텍처를 사용했고, 총 api, application, domain, infra 모듈이 존재합니다.

그리고 api-> application-> domain은 레이어드 아키텍처를 사용했고, 의존성 역전을 통해서 core와 domain을 infra에 의존하지않도록 구성했습니다.

# 각 모듈의 책임

## api 모듈

api 모듈은 표현 계층을 담당하고 있습니다.

여행자와 백오피스 서버가 분리되어야했기 때문에, 여행자와 백오피스 api 모듈이 분리되어있습니다.

따라서, 각 api 모듈은 각자의 main함수를 가집니다.

## application 모듈

application 모듈은 응용 계층입니다.

흐름을 제어하는 역할을 맡으며, 스레드풀 설정과 같은 기술적인 설정도 여행자와 백오피스의 분리가 필요했기 때문에 각각 application 모듈도 분리되어있습니다.

## domain 모듈

domain 모듈은 핵심 비지니스 로직들을 담고 있습니다.

이전 프로젝트에서는 domain을 순수한 자바 클래스로 만들었는데, entity를 domain으로 매핑해줘야하는 의미 없는 코드가 다수 생겨나야했고, 개발 생산성에 치명적이었습니다.

또한 JPA는 자바 표준이기 때문에 외부 기술이라고 단정짓기도 어려웠고, JPA 기술을 중간에 변경하는 경우는 거의 없을것으로 판단했습니다.

## core

코어 모듈은 domain이나 application이 사용할 외부 기술에 대한 interface나 전체 프로젝트에서 사용하는 enum과 util클래스를 담고 있습니다.

아키텍처 구조에서 가장 안쪽에 존재하므로 core라는 이름을 붙여줬습니다.

## infra 모듈

infra 모듈은 core 모듈에서 선언한 인터페이스에 대한 구현체들이 담겨 있습니다.

외부 서비스의 직접적인 호출부를 담당하고 있습니다.

# 의존성 설정

각 모듈간의 참조를 api로 설정하면 사실상 모듈 분리를 하는 의미가 없다고 판단했습니다.

레이어드 아키택처란 바로 아래 레이어에만 의존해야하는데, 그 밑에까지 의존하게 되면서 자유로운 접근이 가능해지기 때문입니다.

이에 따라 모든 의존관계는 implement로 설정했습니다.

# 인터페이스

너무 무분별한 인터페이스는 개발 생산성을 떨어트립니다.

클래스 내부 구현을 보기 위해서 한번더 커맨드 + B를 눌러야하는것은 별거 아닌것 처럼 보일 수 있습니다.

하지만 이러한 작업이 n년동안 여러 개발자들에 의해서 이뤄져야한다면 이는 꽤 큰 개발 생산성 저하를 야기한다고 생각합니다.

그래서 두가지 상황에서만 인터페이스를 사용하기로 했습니다.

* 의존성 역전이나 디자인 패턴을 활용하기 위해 인터페이스를 사용한다.
* 스펙만을 추상화해서 드러내기 위해 인터페이스를 사용한다.

# 새롭게 프로젝트를 진행한다면 개선할점

오랜 개발끝에 정식으로 서비스를 오픈했습니다.

개인적으로 느꼈던 프로젝트의 불편함을 기록하고, 최근에 관심있게 공부한 DDD 방법론의 전략적 설계 파트 내용을 토대로, 다음 프로젝트에서 개선해볼 수 있을 포인트를 팀원들에게 공유해봤습니다.

이 때, 팀원들에게 공유했던 샘플 코드에 대한 주소는 아래와 같습니다.

[git 주소](https://github.com/mj950425/ddd-tactical-design/tree/step3)

팀 내에 공유한 내용들은 아래에서 인용구로 이어집니다.

## DDD 방법론은 코드 레벨의 아키텍처가 아니다.

DDD에 대한 팀내의 관심은 항상 있었습니다. 하지만 대부분의 관심은 전략적 설계에 집중되어있습니다.

전략적 설계 뿐만 아니라, 도메인 지식을 공유하는것이 DDD에서 더 값어치 있는 행위라고 생각했습니다.

> 에릭 에반스가 말하는 DDD 방법론에서 코드 레벨의 아키텍처는 핵심이 아닙니다. 
> 이러한 이유로 코드 레벨의 아키텍처를 micro ddd라고도 부르는 사람도 있습니다. 
> 더 중요한것은 도메인에 대한 이해관계자의 공통된 이해와 도메인 모델과 코드의 일치와 공통된 언어입니다. 
> 이에 따라 용어집과 도메인 모델링을 위키나 readme로 관리하는것도 좋을 것 같습니다.

## 바운디드 컨택스트에 따라서 패키지를 나눈다.

프로젝트 초기에 바운디드 컨택스트에 따른 논리적 코드 분리 의견을 제시했었습니다.

하지만, 이 때에는 팀 내에서 중복 코드에 대한 우려가 컸고 저 또한 트레이드 오프에 대한 실질적 경험이 없어 자신감있게 말하지못했었는데요.

프로젝트 과정중에 장단점을 느끼게 되었고, 적당한 사이즈에서는 바운디드 컨택스트에 따른 논리적 코드 분리가 필요하다고 생각했습니다.


> 매니저와 파트너가 엄연히 다른 바운디드 컨택스트인데, 같은 도메인 모델로 묶으려고하니깐 로직이 점점 복잡해지는것을 느꼈습니다.
> 하나의 도메인에서 if(isPartner) else .. 와 같은 분기점이 생길 수 밖에 없었고 이는 점점 더 유지보수를 어렵게 만들것이라는 확신이 들었습니다. 
> 물론 중복이 생길 수 있지만, 개인적으로 이정도의 중복은 개발 생산성에 큰 영향이 없다고 생각합니다.


## 도메인 패키지에는 뭐가 들어가야할까?

도메인 패키지에 어떤 값이 들어가야하는지 종종 헷갈립니다.

이 때, 도메인의 정의에 대해서 고민해보면 좋습니다.

도메인이란 일단 우리가 소프트웨어로 해결하고자 하는 영역을 의미합니다.

> DDD에서 도메인은 불변식(정책)과 요구사항으로 이루어집니다. 
> 상품 도메인이라면 당연하게 도메인 패키지안에 상품 엔티티, 상품 가격 값 객체, 상품 이름 값 객체, 상품 레포지토리 등등이 들어갑니다. 
> 헷갈리는 부분은 아래와 같습니다.
> 예를 들어서 상품을 만드는데 비속어 검사를 해야한다라는 정책이 있다고 해봅니다. 
> 비속어 검사는 상품과는 관계가 없어 보이기도 합니다. 
> 하지만 비속어가 들어가있는 상품은 등록될 수 없다는게 정책이므로 비속어 검사 클라이언트도 도메인에 들어가야합니다. (물론 구현체는 인프라에 들어갑니다.)

<br/>

아래는 제가 생각한 적절한 구조입니다.

![그림1](/assets/img/experience/project-review/tna3-project/img_10.png)

## 멀티모듈을 사용해야할까?
사실 초기 설계시에는 큰 생각없이, 멀티모듈 구조를 선택했었습니다.

어느정도 사이즈가 있는 프로젝트에서는 의존성의 방향을 강제할 수 있기 때문에 장점이 있습니다만, MSA에서 작은 단위의 프로젝트에서는 큰 의미 없다고 생각이 들었습니다. 

> 바운디드 컨택스트별로 미래에 새로운 서버로 분리될 수 있다는것을 생각해야합니다. 
> 그래서 멀티모듈 프로젝트에서 DDD의 전략적 설계에 맞게 개발하려면 도메인이나, 바운디드 컨택스트별로 모듈을 나눠야합니다. (모듈별로 새로운 서버로 손쉽게 이동하면 되므로)
> 그런데 이렇게되면 하나의 실행파일로 묶이지않습니다. 그래서 고민이드는것은 굳이 멀티모듈 프로젝트가 필요할까? 입니다.  
> 현재는 복잡도가 높은게 아니라면, 단일 모듈에 패키지 레벨에서 나누면 되지않을까? 라는 생각입니다.
> 아니면 어느정도 타협해서 레이어별로 모듈을 나누고, 이 안에서 바운디드 컨택스트별로 패키지를 나누는것도 방법이 될 것 같습니다.

## DTO 개수 최소화
물론 성격이 다른 api들이 DTO를 공유하면 유지보수가 어려워집니다만, 레이어별로 너무 많은 DTO 컨버팅은 큰 안티패턴이라는것을 느꼈습니다.

> 3.0 프로젝트에서는 표현계층에서 받아주는 DTO와 응용계층에서 받아주는 DTO 그리고 도메인에서 받아주는 DTO가 각각 존재했습니다.
> 하지만 많은 수의 DTO는 버그를 만들고 개발 생산성을 떨어트린다는것을 느꼈습니다.
> 먼저 'rest api에서 controller layer의 dto가 필요할까' 입니다. 헥사고날 구조가 아니면 프론트에서 내려주는 데이터의 변환 책임이 전부 application에서 수행됩니다.
> 그렇다면 그냥 application에서 선언한 dto를 controller가 받아서 사용하는게 더 효율적으로 보입니다. 

## 응용 서비스와 도메인 서비스
프로젝트 설계시 도메인 서비스에 대한 명확한 기능을 이해하지못했었습니다. 이에 따른 팀 내에서 혼용해서 사용하는 경우가 발생했고, 이를 명확하게 하고자 했습니다.
> 3.0 에서는 응용 서비스의 역할이 모호합니다. 도메인 서비스와 응용 서비스의 역할을 명확하게 구분하고, 중요한 도메인 로직들만 도메인 서비스에 담는게 좋아보입니다.
> 먼저 도메인이란, 우리가 소프트웨어로 해결하고자하는 영역을 담아야합니다.
> DDD에서는 이러한 도메인을 요구사항과 불변식의 조합으로 보고 있습니다.
> 위키에 작성될법한 정책(불변식)들은 도메인 패키지안에서 관리하는게 좋습니다.
> 만약 정책이 사물이 아니라서 절차적으로 진행되어야한다면, 이런 경우 도메인 서비스를 사용하는게 좋습니다.
> 단순한 흐름 제어는 응용 서비스에서 진행합니다.

## DTO의 책임

> DTO는 외부의 요청을 담는 클래스일뿐 도메인의 관심사가 전혀 아닙니다. 
> 하지만 DTO를 단순 데이터를 운반하는 역할으로 사용할지, 아니면 화면을 그리는데 필요한 데이터를 조작하는 역할까지는 허용할지 팀 내에서 규칙을 다시 정해봐도 좋을 것 같습니다.

## 엔티티와 VO

> VO는 작은 단위로 움직이고 불변객체이므로 DTO처럼 쓰여도 문제가 없습니다.
> VO를 활용하게되면 로직을 캡슐화 할 수 있다는 장점이 있습니다.
> 아래는 상품의 이름을 VO로 변경한 코드입니다.

## 도메인 이벤트
Transactional consistency에서 도메인 이벤트는 보상 트랜잭션 패턴을 적용해야합니다.
이는 꽤나 복잡한 구조를 만들어야하는데, 이게 앞으로 필요할지 고민해봤습니다.
> 생각보다 대부분의 경우에서는 트랜잭션을 묶지않고 도메인 이벤트로 로직을 수행하는게 문제가 되지않습니다.
> 하지만 문제가 되는 경우가 생긴다면, 배치를 통해서 값을 조절해주거나 보상 트랜잭션을 사용할 수 있습니다. 
> 하지만 우리 프로젝트에서는 기존처럼 같은 트랜잭션으로 묶어주는것이 손쉬운 방법으로 보입니다.
> 이에 대한 의논도 나눠보면 좋을 것 같습니다.

## CQRS
CQRS의 장점은 도메인 로직(보통 업데이트)에서 단순 조회를 분리할 수 있다는 것과 더 높은 트래픽을 감당할 수 있다는 점입니다.
이 또한 우리 프로젝트에서 필요한 기능을지 고민해봤습니다.

> 애그리게이트의 불변식을 보장하기 위해서 데이터는 전부 이거로딩으로 설정하는게 좋습니다. 
> 생각보다 비지니스에서 조인 하나 더 거는것은 큰 문제가 되지 않습니다.
> 그런데 조회가 빈번한 로직들은 문제가 될 수 있습니다.
> 대부분 조회 로직들은 객체지향이 필요 없습니다. 또한 JPA로 복잡한 쿼리를 만든다는것은 어렵습니다.
> 그렇기 때문에 CQRS를 분리하는것이 좋습니다. command에서 데이터를 flat한 json으로 저장하고 이를 query에서 사용하는게 좋습니다.
> CQRS에서 변경을 위한 조회는 Q로 보고있지않습니다. 액터가 어떤 동작을 위해 액션을 취하는것인지 판단해야합니다.
> 하지만 우리의 비지니스 복잡도와 트래픽이 이러한 아키텍처를 필요로하는지는 팀내에서 다시 이야기 나눠보면 좋을 것 같습니다. 

## Fake 객체
> mockk을 통해서 every{…}로 테스트코드를 작성하는것은 이미 내부 구현을 자세하게 들여다보는 화이트 박스 테스트에 해당합니다.
> 하지만 해당 테스트에서 내부 구현에 대한 과정을 감추는게 단위 테스트의 의의에 더 적합하다고 생각합니다.
> 이런 관점에서 단순한 객체들은 Fake로 만들어서, 테스트하는것이 유닛 테스트의 의의에 어울린다고 생각합니다.

## 벨리데이션에 대한 규칙
> 3.0에서는 벨리데이션 로직이 응용 계층과 도메인에 분산되어있습니다. 
> 도메인에서만 적용하는것을 팀 내 규칙으로 가져가는것도 좋을 것 같습니다.
> 응용 계층은 단순한 흐름 제어만 하는게 좋을 것 같습니다.


# 래퍼런스

- 조영호님의 DDD 세미나
- nextstep의 DDD 세레나데