# C++의 DLL과 자바의 동적 링킹 비교
C++에서 DLL(Dynamic Link Library)을 사용할 때, 새로운 버전을 배포하는 경우 실행 파일을 새로 빌드할 필요가 없습니다. 

단지 새로운 버전의 DLL을 빌드하고 배포하기만 하면 됩니다. 이후 동적 링킹이 자동으로 새 DLL을 참조하게 됩니다.

반면, 자바의 경우에는 동적 링킹을 사용함에도 불구하고, 실행 파일도 새롭게 빌드해야 합니다. 

이는 자바가 운영체제가 아닌 JVM(Java Virtual Machine)의 클래스 로더를 통해 링킹을 수행하기 때문입니다. 

새로운 버전의 라이브러리를 로드하려면 해당 라이브러리의 바이트코드가 미리 생성되어 있어야 합니다.

# Spring Boot 프로젝트에서의 Gradle 종속성 관리

## 1단계: Gradle의 종속성 선언
여러 모듈로 구성된 Spring Boot 프로젝트에서 각 모듈에는 종속성이 선언되는 자체 build.gradle 파일이 있습니다.
모듈 A의 build.gradle: 모듈 B에 대한 종속성을 선언하지만 모듈 C에 대한 종속성은 선언하지 않습니다.
모듈 B의 build.gradle: 모듈 C에 대한 종속성을 선언합니다.

## 2단계: 컴파일 및 의존성 해결
컴파일 중: 모듈 A를 컴파일할 때(예: gradle 빌드 실행) Gradle은 모듈 A의 build.gradle에 선언된 종속성을 확인합니다. 

모듈 A가 모듈 B에 종속되어 있음을 발견하고 모듈 B의 클래스를 사용할 준비를 합니다.

직접 종속성: 모듈 A는 모듈 B에 대해 알고 있으며 그 클래스를 직접 사용할 수 있습니다.

전이적 종속성: 모듈 A는 모듈 C가 빌드.gradle에서 직접 선언되지 않았기 때문에 모듈 C에 대해 알지 못합니다. 

따라서 모듈 A에서 모듈 C의 클래스를 직접 사용할 수 없으며, 그렇게 하려고 하면 컴파일 오류가 발생합니다.

## 3단계: 실행 가능한 JAR(Fat JAR) 만들기
Spring Boot Fat JAR: Spring Boot 애플리케이션을 실행 가능한 JAR로 패키징하면(예: ./gradlew bootJar 사용), 필요한 모든 종속성이 포함됩니다.

종속성 번들링: 이 프로세스는 모듈 A(예: 모듈 B)의 직접 종속성뿐만 아니라 전이 종속성(예: 모듈 C)도 번들로 묶습니다.

결과: 결과: 모듈 A에 대한 최종 JAR 파일은 독립적이며 모듈 B와 모듈 C를 포함합니다.

## 4단계: 런타임 동작
JAR 실행: 모듈 A를 실행하면(java -jar ModuleA.jar), 예상대로 모듈 B의 기능을 사용할 수 있습니다.

모듈 B가 모듈 C에 액세스하기: 모듈 B는 모듈 C에 종속되어 있고 이러한 모든 종속성이 최종 JAR에 함께 번들로 제공되므로 모듈 B는 런타임에 원활하게 모듈 C에 요청하거나 모듈 C의 기능을 사용할 수 있습니다.

결론

요약하면 다음과 같습니다:

빌드 시간: 컴파일/빌드 시 모듈 A는 모듈 B의 기능만 직접 사용할 수 있고 모듈 C는 사용할 수 없습니다. 

모듈 A에서 모듈 C를 직접 사용하려고 하면 모듈 A의 build.gradle이 모듈 C에 대한 종속성을 선언하지 않기 때문에 컴파일 오류가 발생합니다.

런타임: 최종 패키지(Fat JAR) 애플리케이션에서는 모든 종속성(전이 종속성 포함)이 함께 번들로 제공됩니다. 

따라서 모듈 A는 모듈 B를 사용할 수 있고, 모듈 B는 내부적으로 모듈 C를 사용할 수 있으므로

런타임 작업이 원활하게 이루어집니다.

그러니깐 컴파일 타임에는 모듈 A에만 한정되어서 컴파일러가 동작하니깐 C를 사용하려고하면 라이브러리에 등록이 안되어있어서 에러를 발생시키고, 런타임에는 FatJar가 하나의 실행파일로 C까지 라이브러리로 포함시켰으니 A가 B를 호출하고 B가 C를 호출해도 에러가 발생하지 않는다.

멀티모듈 스프링 부트 설정에서 모듈 A와 모듈 C가 동일한 팻 병에 함께 패키징되어 있지만, 특히 모듈 A가 모듈 C에 대한 컴파일 타임 종속성이 없는 경우 런타임에 모듈 A에서 모듈 C로 직접 액세스하는 것은 간단하지 않습니다. 자세한 설명은 다음에서 확인할 수 있습니다:

컴파일 타임 종속성: 여기서 핵심 요소는 의존성 선언입니다. 모듈 A가 빌드 구성에서 모듈 C에 대한 종속성을 선언하지 않으면(예: Maven의 pom.xml 또는 Gradle의 build.gradle), 모듈 A는 컴파일 중에 모듈 C의 클래스 또는 리소스에 직접 액세스할 수 없습니다. 즉, 모듈 A의 코드에서 모듈 C의 메서드를 직접 호출하거나 클래스를 사용할 수 없습니다.

런타임 액세스: 런타임 시에는 모듈 A, B, C의 모든 클래스가 실제로 지방 항아리 내에서 동일한 클래스 경로에 있습니다. 그러나 리플렉션이나 동적 클래스 로딩과 같은 기술을 사용하지 않는 한 모듈 A는 기본적으로 모듈 C의 기능에 직접 액세스할 수 없습니다. 이러한 기법은 복잡하고 추적하기 어려운 버그를 생성할 가능성이 있으므로 일반적으로 사용하지 않는 것이 좋습니다.

모듈 B를 통한 간접 액세스: 모듈 A에서 모듈 C의 기능에 액세스하는 일반적이고 유지 관리가 쉬운 방법은 모듈 B를 통해 간접적으로 액세스하는 것입니다. 모듈 B가 모듈 C를 활용하는 API 또는 서비스를 제공하는 경우, 모듈 A는 이를 사용하여 모듈 C 기능과 상호 작용할 수 있습니다. 이 접근 방식은 우려 사항을 깔끔하게 분리하고 모듈식 아키텍처 원칙을 준수합니다.

디자인 고려 사항: 모듈 A가 모듈 C의 기능에 직접 액세스해야 하는 경우 모듈의 설계를 재고해 볼 필요가 있습니다. 이는 모듈 A가 모듈 C에 직접 종속되어야 하거나 일부 기능을 모듈 전체에서 리팩토링하거나 재구성해야 한다는 것을 의미할 수 있습니다.

요약하면, 기술적으로는 가능하지만 선언된 종속성 없이 런타임에 모듈 A에서 모듈 C에 직접 액세스하는 것은 간단하지 않으며 일반적인 모듈 설계 원칙에 어긋납니다. 권장되는 접근 방식은 모듈 B를 통해 모듈 C에 액세스하거나 모듈 종속성 및 아키텍처를 재평가하는 것입니다.