---
layout: post
title: "MVCC"
date: 2023-11-13 08:46:00 +0900
categories:
  - db
description: >
  'MVCC에 대해서 정리해봤습니다.'
---

# MVCC

MVCC는 동시성을 컨트롤하는 대표적인 기법 중 하나로, Multi Version Concurrency Control의 약자입니다.

## Concurrency control

다른 concurrency control의 대표적인 기법 중 하나로는 lock-based가 있습니다.

이 때 사용하는 lock이 row-level lock인데요.

row-level lock에는 크게 shared lock과 exclusive lock의 두 종류가 있습니다.

shared lock은 읽기 작업에 사용되는 lock으로, 다른 트랜잭션에서 같은 레코드에 대한 shared lock을 얻으려고 할 떄 트랜잭션을 블락하지 않습니다.

즉, 두개의 트랜잭션이 하나의 레코드를 읽는게 가능합니다. 하지만 쓰기는 불가능합니다.

exclusive lock은 쓰기 작업에 사용되는 lock으로 unlock 이전까지 다른 트랜잭션이 shared lockd이나 exclusive lock을 얻을 수 없습니다.

이를 표로 나타내면 아래와 같습니다. 이는 많은 동시성을 제어하기 때문에 성능이 좋지않습니다.

|            | T2 - read | T2 - write |
|------------|-----------|------------|
| T1 - read  | Non Block | Block      |
| T1 - write | Block     | Block      |

## MVCC의 등장

그래서 현재 대부분의 DBMS에서는 잠금 기법과 MVCC를 같이 사용하는데요.

이 경우 동시성을 표로 나타내면 아래와 같습니다. 두개의 트랜잭션이 하나의 레코드를 가지고 서로 write하는 경우가 아니라면 블락하지않기 때문에 더 높은 동시성을 가질 수 있습니다.

|            | T2 - read | T2 - write |
|------------|-----------|------------|
| T1 - read  | Non Block | Non Block  |
| T1 - write | Non Block | Block      |

MVCC에서는 먼저 **특정 시점을 기준**으로 가장 최근에 커밋된 데이터를 읽습니다.

이것을 Mysql에서는 consistent read라고 부르며, 특정 시점은 transaction isolation level에 따라 달라집니다.

Mysql8.0 이상의 기본 엔진인 innoDB에서는 기본적으로 transaction isolation level으로 repeatable read을 사용하는데요.

repeatable read은 **트랜잭션의 시작 시간을 기준**으로 가장 최근에 커밋된 데이터를 읽습니다.

그래서 아래 예시와 같이 동작합니다.

1. 기존의 x 값은 10
2. 트랜잭션 B 시작, 트랜잭션 B에서 write(x = 50)을 통해 x의 값을 50으로 변경함
3. 트랜잭션 A 시작, 트랜잭션 A에서 read(x)하면 10을 읽음, 트랜잭션 B에서 아직 커밋을 안했기 때문에 A는 undo에 있는 데이터를 읽게되는것임
4. 트랜잭션 B에서 커밋
5. **트랜잭션 A에서 다시 read(x)해도 A 트랜잭션 시작 시간(2번 순서)을 기준으로 가장 최근에 커밋된 데이터 10을 읽음**

반대로 isolation level을 read committed로 가져간다면, **read하는 시간을 기준**으로 가장 최근에 커밋된 데이터를 읽습니다.

그래서 아래 예시와 같이 동작합니다.

1. 기존의 x 값은 10
2. 트랜잭션 B에서 write(x = 50)
3. 트랜잭션 A에서 read(x)하면 10을 읽음, 트랜잭션 B에서 아직 커밋을 안했기 때문에 A는 undo에 있는 데이터를 읽게되는것임
4. 트랜잭션 B에서 커밋
5. **트랜잭션 A에서 다시 read(x)하면 read(x)하는 시점에 가장 최근에 커밋된 데이터 50을 읽음**

MVCC에서는 커밋된 데이터를 읽기 때문에, transaction isolation level read uncommitted는 이용 불가능합니다.

또한 MVCC에서는 Undo파일을 통해서 데이터의 변화 이력을 관리합니다.

이로 인한 추가적인 저장공간이 필요합니다.

다른 트랜잭션이 변경 중인 데이터를 읽을 때, Undo 파일에 저장된 이전 버전의 데이터를 읽게 됩니다.

이로 인해서 두개의 트랜잭션이 서로 write를 하려는게 아니라면, 트랜잭션을 블락하지 않습니다.

덕분에 성능이 더 잘 나옵니다.

## Lost Update

Lost Update란 말 그대로 사라진 업데이트 쿼리를 뜻하는데요.

아래 예시를 통해서 살펴보겠습니다.

A 트랜잭션와 B 트랜잭션의 isolation level이 read committed 이라고 가정해봅니다.

x의 초기값은 50이고 y의 초기값은 10입니다. 이 때, A 트랜잭션에서는 x가 y에게 40을 이체하고, B 트랜잭션에서는 x에 10을 입금합니다.

아래와 같은 흐름으로 동작하는 경우를 살펴봅니다.

1. A 트랜잭션에서 read(x)의 값을 50으로 읽습니다.
2. A 트랜잭션에서 write(x = 10)를 통해서 x에 대한 write lock을 가져오고, x의 값을 10으로 업데이트합니다.
3. B 트랜잭션에서 read(x)의 값을 50으로 읽습니다.
4. B 트랜잭션에서 write(x = 60)을 통해서 write lock을 가져오려고 하지만 이미 x에 write lock이 A 트랜잭션에 잡혀있으므로 대기합니다.
5. A 트랜잭션에서 read(y)의 값을 10으로 읽습니다.
6. A 트랜잭션에서 wrtie(y = 50)을 통해서 y에 대한 write lock을 가져오고, y의 값을 50으로 업데이트합니다.
7. A 트랜잭션에서 커밋합니다. 커밋을하면 자동적으로 락이 풀립니다. x = 10, y = 50이 데이터베이스에 기록됩니다.
8. 4번 과정에서 대기하던 B 트랜잭션이 x에 대한 락을 획득합니다.
9. B 트랜잭션에서 write(x = 60)을 통해서 x에 대한 write lock을 가져오고, x의 값을 60으로 업데이트합니다.
10. B 트랜잭션에서 커밋합니다. 커밋을하면 자동적으로 락이 풀립니다. x = 60이 데이터베이스에 기록됩니다.

결과적으로 A가 수행한 x값의 업데이트는 데이터가 사라졌고, 우리가 기대했던 값과는 다르게 x의 값은 60, y의 값은 50이 됩니다.

일반적으로 lock based concurrency control에서는 2PL을 적용하면 발생하지 않는데요.

MVCC에서는 어떻게 해결하는지 알아보겠습니다.

## PostgreSQL의 Repeatable Read를 통한 Lost Update 문제 해결

PostgreSQL에서는 해당 문제를 B의 트랜잭션 isolation level을 repeatable read로 변경하면서 손쉽게 해결할 수 있습니다. 참고로 트랜잭션별로 다른 isolation level을
부여하는것이 가능합니다.

PostgreSQL에서는 트랜잭션의 isolation level이 repeatable read인 경우, 같은 데이터에 먼저 update한 트랜잭션이 커밋되면 나중 트랜잭션은 롤백됩니다.

결국 A가 먼저 커밋했기 떄문에, 위의 9번 과정에서 B 트랜잭션이 롤백처리됩니다.

하지만 실제로는 위와 같은 순서대로 동작하는게 아닐 수도 있기 떄문에 A와 B 둘 다 repeatable read로 isolation level을 설정해야합니다.

## Mysql의 Repeatable Read를 통한 Lost Update 문제 해결

Mysql은 PostgreSQL와 다르게 repeatable read라고 해서, 같은 데이터에 먼저 update한 트랜잭션이 커밋되었을때 나중 트랜잭션을 롤백하는 기능이 없습니다.

그렇기 때문에 Mysql에서는 read할 때 locking read를 해야합니다.

locking read란 아래와 같은 쿼리입니다. 이 부분은 개발자가 직접 컨트롤해야합니다. Mysql이 직접 repeatable read라고해서 select 쿼리를 아래처럼 자동으로 바꿔주지않습니다.

```
select balance from account where id = 'x' for update
```  

이렇게 쿼리를 실행하면 read를 하면서도 x에 대한 쓰기락을 취득하게 됩니다. 쓰기락이 이미 다른 트랜잭션에 의해 점유되고 있다면 값을 읽지않고 대기합니다. 

또한 locking read를 실행하면 isolation level이 repeatable read라고 해도 가장 최근의 커밋된 데이터를 읽습니다.

이게 read committed와 똑같이 동작하는것은 아닙니다. repeatable read는 하나의 트랜잭션에서 같은 값을 읽는것은 동일합니다. 

다만 트랜잭션을 시작할때 시점의 값을 읽는게 아니라, 읽을때의 가장 최근에 커밋된 값을 바라본다는것입니다. 

그래서 "x의 초기값은 50이고 y의 초기값은 10일때, A 트랜잭션에서 x가 y에게 40을 이체하고 B 트랜잭션에서 x에 10을 입금합니다." 라는 위의 예제를 다시 살펴보겠습니다.

A 트랜잭션과 B 트랜잭션이 locking read를 수행하는 경우에는 어떻게 동작하는지 알아봅니다.

1. A 트랜잭션에서 lockingRead(x)의 값을 50으로 읽습니다. 이 때 x에 대한 쓰기락을 트랜잭션 A에서 가져옵니다.
2. A 트랜잭션에서 write(x = 10)를 통해서 x의 값을 10으로 업데이트합니다.
3. B 트랜잭션에서 lockingRead(x)의 값을 읽으면서 x에 대한 쓰기락을 획득하려고하는데, 이미 x에 대한 락이 A에 잡혀있으므로 읽지 못하고 대기합니다.
5. A 트랜잭션에서 lockingRead(y)의 값을 10으로 읽고 y에 대한 쓰기락을 트랜잭션 A에서 가져옵니다.
6. A 트랜잭션에서 wrtie(y = 50)을 통해서 y의 값을 50으로 업데이트합니다.
7. A 트랜잭션에서 커밋합니다. 커밋을하면 자동적으로 락이 풀립니다. x = 10, y = 50이 데이터베이스에 기록됩니다.
8. 3번 과정에서 대기하던 B 트랜잭션이 x에 대한 쓰기락을 획득하면서, x의 값을 읽습니다. 이 떄, locking read를 통해서 읽으므로 가장 최근의 커밋된 값 10으로 x 데이터를 읽습니다.
9. B 트랜잭션에서 write(x = 20)을 통해서 x의 값을 20으로 업데이트합니다.
10. B 트랜잭션에서 커밋합니다. 커밋을하면 자동적으로 락이 풀립니다. x = 20이 데이터베이스에 기록됩니다.

Locking Read에는 SELECT ... FOR UPDATE, SELECT ... FOR SHARE 로 두개가 존재합니다.

SELECT ... FOR UPDATE는 exclusive lock을 획득하는것이고 SELECT ... FOR SHARE는 share lock을 획득하는것입니다.

Lost Update 말고도 write skew라는 문제도 존재하는데요.

