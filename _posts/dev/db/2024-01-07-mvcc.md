---
layout: post
title: "MVCC"
date: 2024-01-07 08:46:00 +0900
categories:
  - db
description: >
  'MVCC에 대해서 정리해봤습니다.'
---

# MVCC

MVCC는 데이터베이스의 동시성을 제어하는 주요 기법 중 하나입니다. 

이 기법에 대한 이해를 돕기 위해, 기본적인 개념과 함께 MVCC의 작동 방식을 살펴보겠습니다.

# 동시성 제어 (Concurrency Control)

동시성 제어의 다른 접근 방식으로는 'lock-based' 기법이 있습니다.

이 기법에서 사용되는 'row-level lock'에는 'shared lock'과 'exclusive lock' 두 종류가 있습니다

Shared lock은 읽기 작업에 사용되며, 다른 트랜잭션이 같은 레코드에 대해 shared lock을 요청할 때 트랜잭션을 차단하지 않습니다.

반면, exclusive lock은 쓰기 작업에 사용되며, 다른 트랜잭션이 해당 레코드에 대해 어떤 lock도 획득할 수 없게 됩니다.

이러한 lock 기법은 동시성을 제한하기 때문에 성능 저하의 원인이 될 수 있습니다.

|            | T2 - read | T2 - write |
|------------|-----------|------------|
| T1 - read  | Non Block | Block      |
| T1 - write | Block     | Block      |

# MVCC의 등장

대부분의 현대적인 DBMS는 lock 기법과 MVCC를 결합해 사용합니다.

MVCC를 사용할 때의 동시성은 다음과 같이 향상됩니다.

두 트랜잭션이 동일한 레코드에 대해 쓰기 작업을 하지 않는 이상, 트랜잭션 간 차단이 발생하지 않습니다.

|            | T2 - read | T2 - write |
|------------|-----------|------------|
| T1 - read  | Non Block | Non Block  |
| T1 - write | Non Block | Block      |


MVCC에서는 트랜잭션이 특정 시점을 기준으로 가장 최근에 커밋된 데이터를 읽으며, 이것을 consistent read라고 부릅니다.

특정 시점은 트랜잭션의 isolation level에 따라 달라집니다.

MySQL의 innoDB의 경우, 기본적으로 'repeatable read' 격리 수준을 사용하는데요.

이 경우에는, 트랜잭션 시작 시간을 기준으로 가장 최근에 커밋된 데이터를 읽게됩니다.

그래서 아래 예시와 같이 동작합니다.

1. 기존의 x 값은 10
2. 트랜잭션 B 시작, 트랜잭션 B에서 write(x = 50)을 통해 x의 값을 50으로 변경함
3. 트랜잭션 A 시작, 트랜잭션 A에서 read(x)하면 10을 읽음, 트랜잭션 B에서 아직 커밋을 안했기 때문에 A는 undo에 있는 데이터를 읽게되는것임
4. 트랜잭션 B에서 커밋
5. **트랜잭션 A에서 다시 read(x)해도 A 트랜잭션 시작 시간(2번 순서)을 기준으로 가장 최근에 커밋된 데이터 10을 읽음**

반대로 격리 수준을 'read committed' 로 가져간다면, 데이터를 읽는 시점을 기준으로 가장 최근에 커밋된 데이터를 읽습니다.

그래서 아래 예시와 같이 동작합니다.

1. 기존의 x 값은 10
2. 트랜잭션 B에서 write(x = 50)
3. 트랜잭션 A에서 read(x)하면 10을 읽음, 트랜잭션 B에서 아직 커밋을 안했기 때문에 A는 undo에 있는 데이터를 읽게되는것임
4. 트랜잭션 B에서 커밋
5. **트랜잭션 A에서 다시 read(x)하면 read(x)하는 시점에 가장 최근에 커밋된 데이터 50을 읽음**

MVCC는 커밋된 데이터만 읽기 때문에, 'read uncommitted' 격리 수준은 사용할 수 없습니다.

MVCC 기법은 Undo 파일을 사용하여 데이터의 변경 이력을 관리하며, 이는 추가적인 저장 공간을 필요로 합니다.

다른 트랜잭션이 변경 중인 데이터를 읽을 때, Undo 파일에 저장된 이전 버전의 데이터를 읽게 됩니다.

이로 인해서 두개의 트랜잭션이 서로 write를 하려는게 아니라면, 트랜잭션을 블락하지 않습니다.

덕분에 성능이 더 잘 나옵니다.

# Lost Update

Lost Update는 두 트랜잭션이 동시에 동일한 데이터를 수정할 때 발생하는 문제입니다. 

이 문제를 이해하기 위해, 아래와 같은 시나리오를 살펴보겠습니다.

### 시나리오 설명
두 트랜잭션 A와 B가 있으며, 둘 다 'read committed' 격리 수준을 사용한다고 가정합니다. 

x의 초기값은 50, y의 초기값은 10입니다. A 트랜잭션은 x에서 y로 40을 이체하고, B 트랜잭션은 x에 10을 입금합니다.

### 트랜잭션 실행 과정
1. A 트랜잭션은 x의 값을 50으로 읽습니다.
2. A는 x에 대해 write lock을 설정하고 x의 값을 10으로 변경합니다.
3. B 트랜잭션은 x의 값을 50으로 읽습니다.
4. B는 x에 대해 write lock을 시도하지만, A에 의해 이미 lock이 설정되어 대기합니다.
5. A는 y의 값을 10으로 읽습니다.
6. A는 y에 대한 write lock을 설정하고 y의 값을 50으로 변경합니다.
7. A는 커밋을 하여 모든 lock을 해제합니다. 데이터베이스에는 x = 10, y = 50으로 기록됩니다.
8. B는 이제 x에 대한 lock을 획득합니다.
9. B는 x의 값을 60으로 변경합니다.
10. B는 커밋을 하여 모든 lock을 해제합니다. 최종적으로 x = 60이 데이터베이스에 기록됩니다.

결과적으로, A 트랜잭션에 의한 x값의 변경은 사라지고, 최종적으로 x는 60, y는 50이 됩니다.

일반적으로 lock based 동시성 제어에서는 2단계 잠금 프로토콜(2PL)을 적용하여 이런 문제를 방지합니다. 

MVCC 환경에서는 이 문제를 어떻게 해결하는지 살펴보겠습니다.

# PostgreSQL의 Repeatable Read를 통한 해결 방법
PostgreSQL에서는 Lost Update 문제를 해결하기 위해 트랜잭션의 격리 수준을 'repeatable read'로 설정할 수 있습니다.

PostgreSQL에서 격리 수준이 'repeatable read'인 경우, 같은 데이터에 대해 먼저 업데이트한 트랜잭션이 커밋되면 이후 트랜잭션은 롤백됩니다.

따라서, 위 예시에서 A가 먼저 커밋했기 때문에, B 트랜잭션은 9번 과정에서 롤백되어 Lost Update 문제가 해결됩니다. 

하지만 실제 운영 환경에서는 여러 가지 순서로 트랜잭션이 실행될 수 있으므로, A와 B 모두 'repeatable read' 격리 수준을 적용하는 것이 안전합니다.

# MySQL의 Repeatable Read를 통한 해결 방법

MySQL은 PostgreSQL과 달리 'repeatable read' 격리 수준에서 자동으로 후행 트랜잭션을 롤백하는 기능이 없습니다. 

따라서 MySQL에서는 'locking read'를 사용해야 합니다.

이는 개발자가 직접 구현해야 하는 쿼리로, MySQL이 관리해주는것이 아닙니다.  

예를 들어, select balance from account where id = 'x' for update 같은 쿼리를 사용하면, 읽기 동작 중에도 x에 대한 쓰기 lock을 취득할 수 있습니다.

이미 다른 트랜잭션에 의해 lock이 점유되어 있다면, 해당 값이 해제될 때까지 대기합니다.

Locking read를 사용하면, 'repeatable read' 격리 수준에서도 가장 최근에 커밋된 데이터를 읽습니다.

그렇다고 'read committed'와 같은 방식으로 작동한다는 의미는 아닙니다.

동일한 트랜잭션 내에서는 일관된 값을 읽지만, 트랜잭션 시작 시점이 아니라 읽는 시점의 가장 최근 커밋된 값을 참조합니다.

이제 "x의 초기값이 50, y의 초기값이 10인 상황에서 A 트랜잭션이 x에서 y로 40을 이체하고, B 트랜잭션이 x에 10을 입금하는" 상황에서 A와 B 트랜잭션이 'locking read'를 사용할 때의 동작을 살펴보겠습니다.

1. A 트랜잭션은 lockingRead(x)를 통해 x의 값을 50으로 읽고, 동시에 x에 대한 쓰기락을 획득합니다.
2. A 트랜잭션은 write(x = 10)를 통해 x의 값을 10으로 업데이트합니다.
3. B 트랜잭션은 lockingRead(x)를 통해 x의 값을 읽으려 하지만, A가 이미 x에 쓰기락을 가지고 있어 대기합니다.
4. A 트랜잭션은 lockingRead(y)를 통해 y의 값을 10으로 읽고, y에 대한 쓰기락을 획득합니다.
5. A 트랜잭션은 write(y = 50)를 통해 y의 값을 50으로 업데이트합니다.
6. A 트랜잭션은 커밋하면, 자동으로 모든 락이 해제되고, x = 10, y = 50이 데이터베이스에 기록됩니다.
7. 이제 B 트랜잭션이 대기하던 x에 대한 쓰기락을 획득하며, locking read를 통해 x의 값을 읽습니다. 이때, 최근에 커밋된 값인 10으로 x의 값을 읽습니다.
8. B는 write(x = 20)을 통해 x의 값을 20으로 업데이트합니다.
9. B가 커밋하면, x = 20이 데이터베이스에 기록됩니다.

Locking Read는 두 가지 형태가 있습니다. 
* SELECT ... FOR UPDATE 
  * exclusive lock을 얻어옵니다.
* SELECT ... FOR SHARE 
  * share lock을 얻어옵니다.




