---
layout: post
title: "그림으로 배우는 리눅스 구조를 읽고.."
date: 2023-12-31 08:46:00 +0900
categories:
  - study
  - book
description: >
  '그림으로 배우는 리눅스 구조를 읽고..'
---

# 그림으로 배우는 리눅스 구조를 읽고..

운영하는 애플리케이션이 리눅스 위에서 동작하고있다보니, 꼭 읽어봐야겠다라고 생각하던 책을 이제서야 읽게되었습니다.

책을 구매한지는 6개월정도된 것 같네요. 하하..

# 목차별 내용 요약

## 1장 리눅스 개요
커널은 운영체제의 핵심 프로그램을 의미한다. 

시스템 콜이란 프로세스가 커널에 처리를 요청하는것을 의미한다.

프로세스는 하드웨어에 직접 접근할 수 없고, 무조건 시스템 콜을 통해서 커널에게 하드웨어 자원을 요청해야한다.

그러면 커널은 cpu를 사용자모드에서 커널 모드로 전환하고, 커널 모드의 cpu는 하드웨어에 접근이 가능해진다.

시스템 콜은 어셈블리로 아키텍처에 맞게 작성되어야만 호출할 수 있다. 결국 사용하는 아키텍처가 x86이거나 arm64인지에 따라 어셈블리가 달라져야한다. 

또한 C와 같은 고급 언어에서는 직접 호출할 수 없고, 인라인 어샘블리를 사용해야합니다. 

그래서 시스템콜을 호출해야할때는, OS가 제공하는 라이브러리의 시스템 콜 래퍼 함수를 사용한다.

리눅스는 프로세스가 손쉽게 시스템 콜을 할 수 있도록 C로 만들어진 라이브러리를 제공한다.

정적 라이브러리는 소스 코드를 컴파일할때 실행 파일에 라이브러리를 포함시키는것이고, 공유 라이브러리는 런타임에 라이브러리를 로드하고 실행하는 방식이다.

## 2장 프로세스 관리
### 프로세스 실행
리눅스에서 아래 함수로 프로세스를 생성한다.
- fork() : 부모 프로세스에서 자식 프로세스를 복사한다. 
- execve() : 원하는 프로그램을 자식 프로세스의 메모리에 덮어쓴다.

컴퓨터를 처음 부팅하면 아래와 같이 동작합니다.

1. 컴퓨터 전원을 킴
2. BIOS 펌웨어를 가동하고 하드웨어를 초기화  
3. 펌웨어가 부트로더를 가동
4. 부트 로더가 OS 커널을 가동
5. 리눅스 커널이 init 프로세스를 가동
6. init 프로세스가 자식 프로세스를 기동하고, 그리고 자식의 자식 프로세스를 기동하고.. 이렇게 이어져서 프로세스 트리 구조를 생성

### 프로세스 상태 
프로세스의 상태로는 아래처럼 존재합니다.
- 프로세스 탄생 
- 실행 가능상태
- 실행 상태
- 슬립 상태
- 좀비 상태
  - 프로세스가 종료되어도, 부모 프로세스가 자식 프로세스의 종료 여부나 CPU 사용 누적 데이터를 조회할 수 있도록, 좀비 형태로 남아있는다.
  - 부모 프로세스가 wait()을 호출하여, 해당 정보를 조회하면 그제서야 사라진다.
- 프로세스 종료

### 시그널
프로세스는 기본적으로 정해진 순서에 따라 실행된다.

이에 비해 시그널은 어떤 프로세스가 다른 프로세스에 신호를 보내서 외부에서 실행 순서를 강제적으로 바꾸는 방법이다.

각 프로세스는 시그널 핸들러를 미리 등록한다. 프로세스를 실행하다가 해당하는 시그널을 수신하면 실행 중인 처리를 일단 중단하고 시그널 핸들러에 등록한 처리를 동작시킨다.

우리가 bash 셀에서 사용하는 Ctrl + C도 대표적인 SIGINT라는 시그널을 보내는것이며, SIGINT 시그널을 받은 프로세스는 곧바로 종료하는게 기본값이다.

### 세션
- 세션: 터미널 또는 ssh 등을 사용해서 시스템에 로그인했을 때의 로그인 세션을 의미
  - 로컬에서 터미널을 실행시키면, 터미널을 실행한 사용자의 계정으로 로그인
- 터미널: 사용자가 명령을 입력하고 결과를 보는 인터페이스
  - 터미널 자체는 명령을 해석하거나 실행하지 않고 단순히 입력과 출력을 중개하는 역할
- 쉘: 터미널 내에서 실행되는 프로그램으로, 사용자가 입력한 명령을 해석하고 실행함
  - Bash는 그 중 하나

세션에 할당된 단말의 연결이 끊기면 쉘에는 SIGHUP 시그널이 보내진다.

이 때 쉘은 자신이 관리하던 작업을 종료시키고, 자신도 종료한다.

종료되지 않기를 원하는 프로세스는 nohup 명령어를 사용하면 된다.

### 프로세스 그룹
- 프로세스 그룹: 프로세스를 묶어서 관리하기 위함 
  - 기본적으로 하나의 쉘이 만드는 프로세스들은 전부 같은 프로세스 그룹에 속함

### 데몬
- 데몬 프로세스: 상주하는 프로세스를 의미
  - 단말 입출력이 필요없으므로 할당된 단말 없음
  - 독자적인 세션 존재
  - 데몬의 부모는 init 프로세스

## 3장 프로세스 스케줄러
- 경과시간 : 프로세스 시작부터 종료할 때 까지 경과한 시간
- 사용 시간 : 프로세스가 실제 논리 CPU를 사용한 시간

컨택스트 스위치는 프로세스가 어떤 코드를 실행하고 있든 간에 타임 슬라이스가 끝나면 주저없이 발생한다.

- 턴 어라운드 타임 : 처리 시간. 시스템에 처리를 요청했을 때부터 처리가 끝날 때 까지 걸린 시간
- 스루풋 : 처리량. 단위 시간단 처리를 끝낸 개수

응답 성능이 중요한 시스템이라면, 스루풋이 중요한 시스템에 비해서 시스템을 구성하는 각 기기의 CPU 사용률을 낮게 유지하는것이 중요하다.
-> CPU 사용률을 높게 유지하며 여러 작업을 동시에 처리하는것보다, 한 요청에 대한 응답을 최대한 빠르게 하기 위해 CPU의 여유 자원을 남겨두는 것이 중요하다.

## 4장 메모리 관리 시스템
리눅스는 시스템에 설치된 메모리 전체를 커널의 메모리 관리 시스템 기능을 사용해서 관리한다.

메모리는 각 프로세스가 사용할 뿐만 아니라, 커널 자체도 사용한다.

free 명령어
- total : 시스템에 설치된 전체 메모리 용량
- free :  명목상 비어있는 메모리
- buff/cache : 버퍼, 캐시, 페이지 캐시가 이용하는 메모리. 시스템의 비어 있는 메모리가 줄어들면 커널이 해제시킴
- available : 실제로 사용 가능한 메모리로, free + 해제 가능한 커널 내부 메모리 크기를 더한 값
- used : 시스템이 사용중인 메모리에서 buff/cache를 뺀 값

buff/cache
페이지 캐시와 버퍼 캐시는 접근 속도가 느린 저장 장치에 있는 파일 데이터를 접근 속도가 빠른 메모리에 일시적으로 저장해서 접근 속도가 빨라진 것처럼 보이게 하는 커널 기능이다.

저장 장치에 있는 파일 데이터를 읽어와서 메모리에 데이터를 캐시한다.

시스템의 부하가 높아지면, free 메모리가 줄어든다. 이 경우 커널의 메모리 관리 시스템은 buff/cache 영역에서 해제 가능한 메모리 영역을 해제한다.

예를 들어서 저장장치에서 데이터를 읽어서 buff/cache 메모리에 올려뒀는데, 데이터가 변경된게 아직 없다면, 동일한 데이터가 저장장치에 존재하므로 메모리를 해제해도 문제가 없다.

재활용 가능한 메모리를 해제해도 메모리 부족이 해결되지 않으면, 시스템은 메모리가 부족해서 OOM 상태가 된다.

이렇게되면 메모리 관리 시스템이 적당한 프로세스를 골라서 강제 종료시키고, 메모리에 빈 공간을 만드는 OOM Killer라고 하는 무서운 기능을 동작시킨다.

### 가상 메모리가 없을 때 생기는 문제점
1. 메모리 단편화
이 경우 프로그램이 메모리를 확보할 때마다 확보한 메모리가 몇 개의 영역으로 쪼개져 있는지 일일히 관리해야한다. 사실상 불가능하다.
2. 멀티 프로세스 구현이 어려움
메모리의 절대 주소를 사용해야하며 각 프로세스끼리 겹치는 주소가 없어야한다. 사실상 어렵다.
3. 비정상적인 메모리 접근
다른 프로세스가 메모리 침범할 수 있다. 보안상 치명적이다.

이러한 문제 해결을 위해 가상 주소 공간을 프로세스 별로 할당한다.

### 페이지 테이블
페이지 테이블은 가상 주소가 물리 주소의 어떤 위치로 매핑되는지 기록하는 테이블이다.

각 프로세스마다 고유한 페이지 테이블을 가지고 있으며, 이는 커널에 의해 관리된다. 커널은 메모리 관리와 페이지 테이블의 초기화 및 유지보수를 담당한다.

프로세스에 대한 가상 주소의 크기는 고정되어있다. 

처음 프로그램이 가상 메모리를 할당받을 때, 페이지 테이블에 가상 주소가 등록되지만 물리 메모리와는 매핑되지 않은 상태일 수 있다. 

물리 메모리의 할당은 필요한 시점에 이루어진다.

페이지 테이블은 계층화를 통해서 효율적으로 관리하고 또한 페이지의 크기를 크게 잡는다.

이러한 기법이 없으면, x86_64 아키텍처에서 프로세스 한개도 띄우기가 버겁다.

### 페이지 폴트

예를 들어, 가상 주소 공간이 500 바이트인데, 프로세스가 실제로 사용하는 주소는 0~300 바이트라면, 350 바이트에 접근할 때 페이지 폴트가 발생한다.

이는 접근하려는 가상 주소가 페이지 테이블에 매핑되지 않은 상태이기 때문이다.

페이지 폴트는 두 가지 경우에 발생할 수 있습니다:
- 해당 가상 주소가 페이지 테이블에 없을 때 (불법 접근).
- 페이지 테이블에 해당 주소가 존재하지만, 물리 메모리에 매핑되지 않은 경우 (demand paging).

가상 메모리만 할당되고 물리 메모리에 아직 매핑되지 않은 경우, 프로세스가 해당 주소에 실제로 접근할 때 페이지 폴트가 발생한다. 

이때 운영체제는 물리 메모리를 동적으로 할당하고 가상 메모리와 물리 메모리 간의 매핑을 설정한다.
- 이를 Demand Paging 이라고 하며, 필요한 시점에만 물리 메모리를 할당하여 메모리 자원을 효율적으로 사용한다.

## 5장 프로세스 관리
fork() 함수를 호출할 때 부모 프로세스의 메모리를 자식 프로세스에 모두 복사하는 것이 아니라 페이지 테이블만 복사한다.

또한 페이지 테이블 내부에는 쓰기 권한을 관리하는 필드가 있는데, 이 때 부모와 자식 양쪽을 대상으로 모든 페이지에 쓰기 권한을 무효화한다.

그 이후에, 부모나 자식 중 어느쪽이든 데이터를 갱신하려고하면 페이지 공유를 해제하고 프로세스마다 전용 페이지를 만듭니다.

참고로 평소에 실행시키는 자바 프로세스는 fork() + execve()를 사용하기 때문에 Copy on write가 수행되지는 않습니다.

### execve()
execve() 함수를 호출한 직후라면 아직 프로세스용 물리메모리는 페이징 테이블에 매핑되지 않았습니다.

이후에 프로그램이 엔트리 포인트에서 실행을 시작하면 엔트리 포인트에 대응하는 페이지가 존재하지 않으므로 페이지 폴트가 발생한다.

페이지 폴트 처리 결과로 프로세스에 물리 메모리가 할당된다.

### 프로세스 통신

리눅스에는 여러가지 프로세스 통신 방법이 존재한다.

1. 공유 메모리
2. 시그널 : 간단한 시그널밖에 불가능함
3. 파이프 : 터미널에서 |를 통해서 여러 프로세스를 동시에 실행시키는것
4. 소켓



