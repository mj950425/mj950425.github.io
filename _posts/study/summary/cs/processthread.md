# 프로세스와 스레드
프로세스는 운영체제로부터 자원을 할당받는 최소 단위 
스레드는 CPU에 할당받아서 실행을 위한 최소 단위

# 용어
임계영역
- 여러 스레드가 동시에 접근할 수 있는 코드 영역
경쟁조건
- 결과가 스레드간의 실행 순서에 따라 달라질 수 있는 것

# 모니터 vs 세마포어
진입 경쟁: 모니터에서는 notify()로 깨어난 스레드가 락을 다시 획득하기 위해 다른 스레드와 경쟁해야 합니다. 반면 세마포어에서는 허가가 자동으로 해당 스레드에게 할당되어 바로 임계 영역에 진입할 수 있는 구조를 가질 수 있습니다.
동기화의 추상화 수준: 모니터는 락과 조건 변수를 통한 더 고수준의 동기화 추상화를 제공하며, 사용이 상대적으로 단순합니다. 세마포어는 허가의 개수를 직접 관리하며, 스레드의 동기화를 좀 더 세밀하게 제어할 수 있습니다.

# synchronized
synchronized 메소드 하나만 호출해도 모든 객체의 synchronized가 같이 락에 잠긴다.
인스턴스의 모니터를 획득 방법과 클래스의 모니터를 획득하는 2가지 방법이 있다.
같은 모니터라면 재진입이 가능하다. 메소드의 호출 단위가 아니라 스레드 단위로 락이 획득되기 떄문이다.
상속하면 모니터를 공유한다.
synchronized 안에서는 전부 가시성을 유지한다.
모니터는 기본적으로 비공정성이다.

# volatile
모든 스레드가 메인 메모리에서 값을 읽는것. cpu 캐시가 아니라


# test and set
값을 1로 변환시키고 
기존의 값을 반환

# 컨택스트 스위칭
컨택스트는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미한다.
이 정보들은 운영체제가 관리하는 PCB라고 하는 자료구조에 저장된다.

컨택스트 스위칭은 CPU가 프로세스 간 PCB정보를 교체하고 캐시를 비우는 일련의 과정이라 볼 수 있다.

컨택스트가 가지고 있는 정보는 아래와 같다.
- Process ID
- Process State
- Pointer
- Priority
- Program counter
- CPU Registers
- I/O information
- etc

# 프로세스 상태
- new 
- ready
- running
- waiting
- terminating

# 사용자 모드 & 커널 모드
응용프로그램이 하드웨어에 직접 접근하는것을 막기 위해서 사용자 모드와 커널 모드를 분리

사용자 모드에서는 시스템콜을 통해서만 하드웨어에 접근이 가능

# 사용자 수준 스레드 & 커널 수준 스레드
사용자 프로그램에서 관리하는 스레드가 사용자 수준 스레드
운영체제가 관리하는 스레드가 커널 스레드

사용자 수준 스레드가 생긴 이유
1. 플랫폼 추상화: 자바 스레드 모델은 다양한 운영 체제 위에서 일관된 프로그래밍 인터페이스를 제공합니다. 이를 통해 개발자는 운영 체제의 구체적인 스레드 구현에 대해 걱정하지 않고도 멀티스레드 애플리케이션을 개발할 수 있습니다.
2. JVM의 관리 우위: JVM은 애플리케이션 수준에서 스레드의 생명주기, 스케줄링, 동기화 등을 관리함으로써, 운영 체제의 커널 스레드보다 효율적이고 세밀한 스레드 관리가 가능합니다. JVM은 실행 중인 애플리케이션의 동작을 파악하고 최적화할 수 있는 지식을 가지고 있으므로, 이를 통해 성능을 개선할 수 있습니다.
3. 부가 기능의 제공: 자바 스레드 모델은 동기화, 데이터의 일관성 유지, 데드락 감지와 같은 고급 기능을 포함하고 있습니다. 이러한 기능들은 애플리케이션 개발자가 복잡한 멀티스레딩 문제를 보다 쉽게 해결할 수 있도록 돕습니다.

# 자바 스레드 실행 과정

## 1. CPU 할당 받기
메인 스레드가 실행을 시작하기 위해서는 우선 운영 체제의 스케줄러가 메인 스레드에 매핑된 커널 스레드에 CPU 시간을 할당해야 합니다. 이 단계에서 메인 스레드는 실행 준비 상태에 들어갑니다.

## 2. 메인 스레드의 실행
CPU 할당을 받은 후, 메인 스레드는 유저 모드에서 자바 코드를 실행하기 시작합니다. 이 과정 중에 프로그램은 새로운 자바 스레드 생성을 요구할 수 있으며, 그 경우에 해당 스레드 생성 코드까지 실행이 진행됩니다.

## 3. 자바 스레드 생성
새 자바 스레드 생성 시, 커널 스레드와의 매핑이 필요하므로 시스템 호출을 통해 커널 모드로 전환됩니다. 이 과정에는 커널 내에서 새 커널 스레드를 생성하는 작업이 포함됩니다.

## 4. 스레드 매핑과 대기
새롭게 생성된 커널 스레드가 자바 스레드와 매핑된 후, 이 스레드는 실행을 위해 CPU 할당을 기다립니다. 이 대기 기간은 스레드 스케줄링 알고리즘에 의해 결정됩니다.

## 5. 자바 스레드의 실행
CPU 시간을 할당받으면, 매핑된 자바 스레드는 유저 모드에서 해당 스레드의 코드를 실행합니다. 이를 통해 스레드는 독립적으로 자신의 작업을 수행할 수 있습니다.

## 6. CPU 시간의 재할당
운영 체제의 스케줄링으로 인해 다른 스레드에 CPU가 재할당될 경우, 현재 실행 중인 자바 스레드는 일시 중지됩니다. 이는 매핑된 커널 스레드가 CPU를 뺏기는 것과 동일한 결과를 초래합니다.

## 7. 실행 정보 관리
JVM은 자바 스레드를 wait 상태로 전환하고, 스레드의 논리적 실행 정보는 JVM 내부에 유지됩니다. 동시에 운영 체제는 스레드의 하드웨어 상태와 관련된 물리적 실행 정보를 저장합니다.

## 8. 스레드의 재실행
스케줄러가 다시 CPU 시간을 할당하면, JVM 내부에 저장된 정보를 기반으로 자바 스레드는 중단된 위치에서 실행을 재개합니다. 이를 통해 스레드는 이전에 중지된 지점에서 작업을 계속할 수 있습니다.

# 스레드 생성
Thread 클래스 상속
Runnable 구현하고 Thread인자로 전달

# 생명주기와 상태
- new 스레드 객체가 생성됨. 아직 시작안됨. 자바 스레드 객체는 만들었지만 아직 start는 하지않아서 커널 스레드는 없는 상태.
- runnable 실행중이거나 가능한 스레드 상태. 
- watiing 대기중인 스레드로서 다른 스레드가 특정 작업을 수행하기를 기다림. wait()->다른 스레드에 의해서 노티파이, join()->다른 스레드의 작업 종료
- 
- timed_waiting 대기 시간이 지정된 스레드 상태로서 다른 스레드가 특정 작업을 수행하기를 기다림
- blocked 모니터락이 해제될 때 까지 기다리며 차단된 스레드 상태
- terminated 실행이 완료된 상태

![img.png](/assets/img/dev/jvm-lang/processthread/img.png)

# 명령어 
## sleep
네티이트 메서드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저모드로 전환한다.
비용이 작지않다.

## join

## wait

# interrupt
기존에는 false
- interrupted
스레드의 인터럽트 상태 반환
인터럽트가 true이면 false로 변경 및 반환
- isInterrupted
인터럽트의 상태 변경없이 그냥 반환
인터럽트의 상태만 확인할거면 무조건 이것을 쓸 것

# 스레드풀
테스크 생성은 메인 스레드가, 실행은 executor가 한다.
Executor
Executor service

runnable은 반환값 없음, 체크 익셉션 처리 불가

callable은 반환값 있음, 체크 익셉션 처리 가능

# Future

# executorService
shutdownNow()
실행중인 스레드를 인터럽트한다.
하지만 해당 작업이 인터럽트에 응답하는 작업이 아닌 경우 작업 종료를 보장하지 않는다.

특정 스레드에 인터럽트를 걸고, 특정 스레드가 sleep,join, wait을 호출하면 InterruptedException을 발생시킨다.
해당 메소드들은 블로킹 메소드이다.
